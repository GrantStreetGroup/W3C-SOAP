[%
    is_array = element.max_occurs == 'unbounded'
        || ( element.max_occurs && element.max_occurs > 1 )
        || ( element.min_occurs && element.min_occurs > 1 ); %]
subtype '[% module %]:[% element.name %]_type' =>
    as '[% IF is_array %]ArrayRef[[% element.type_module %]][% ELSE %][% element.type_module %][% END %]';
coerce '[% module %]:[% element.name %]_type' =>
    from 'xml_node' =>
    via { __PACKAGE__->_from_xml('[% element.type_module %]') };
[%- IF is_array; %]
coerce '[% module %]:[% element.name %]_type' =>
    from '[% element.type_module %]',
    via {[$_]};
coerce '[% module %]:[% element.name %]_type' =>
    from 'ArrayRef[xml_node]' =>
    via { [ map {__PACKAGE__->_from_xml('[% element.type_module %]')} @$_ ] };
[%- END %]
has [% element.perl_name %] => (
    is            => 'rw',
    isa           => '[% module %]:[% element.name %]_type',
    traits        => [qw{ W3C::SOAP::XSD }],
    predicate     => 'has_[% element.name %]',
[%- IF element.nillable == 'false' %]
    required      => 1,
[%- END %]
    xs_name       => '[% element.name       %]',
    xs_type       => '[% element.type       %]',
    xs_min_occurs => '[% element.min_occurs %]',
    xs_max_occurs => '[% element.max_occurs == 'unbounded' ? 0 : element.max_occurs %]',
    coerce        => 1,
);
